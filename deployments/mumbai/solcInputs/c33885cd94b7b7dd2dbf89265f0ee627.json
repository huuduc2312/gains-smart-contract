{
  "language": "Solidity",
  "sources": {
    "contracts/contracts/GFarmTradingStorageV5.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport \"../interfaces/TokenInterfaceV5.sol\";\nimport \"../interfaces/AggregatorInterfaceV5.sol\";\nimport \"../interfaces/PoolInterfaceV5.sol\";\nimport \"../interfaces/PausableInterfaceV5.sol\";\nimport \"../interfaces/NftInterfaceV5.sol\";\n\ncontract GFarmTradingStorageV5 {\n\n    // Constants\n    uint public constant PRECISION = 1e10;\n    bytes32 public constant MINTER_ROLE = 0x9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a6;\n    TokenInterfaceV5 public constant dai = TokenInterfaceV5(0x04B2A6E51272c82932ecaB31A5Ab5aC32AE168C3);\n    TokenInterfaceV5 public constant linkErc677 = TokenInterfaceV5(0x326C977E6efc84E512bB9C30f76E30c160eD06FB);\n\n    // Contracts (updatable)\n    AggregatorInterfaceV5 public priceAggregator;\n    PoolInterfaceV5 public pool;\n    PausableInterfaceV5 public trading;\n    PausableInterfaceV5 public callbacks;\n    TokenInterfaceV5 public token = TokenInterfaceV5(0x469Cd2AE37BC3d579eE2c4F0B5e31eA212Fa405E);\n    NftInterfaceV5[5] public nfts = [\n        NftInterfaceV5(0xF9A4c522E327935BD1F5a338c121E14e4cc1f898),\n        NftInterfaceV5(0x77cd42B925e1A82f41d852D6BE727CFc88fddBbC),\n        NftInterfaceV5(0x3378AD81D09DE23725Ee9B9270635c97Ed601921),\n        NftInterfaceV5(0x02e2c5825C1a3b69C0417706DbE1327C2Af3e6C2),\n        NftInterfaceV5(0x2D266A94469d05C9e06D52A4D0d9C23b157767c2)\n    ];\n    address public vault;\n    address public tokenDaiRouter;\n\n    // Trading variables\n    uint public maxTradesPerPair = 3;\n    uint public maxTradesPerBlock = 5;\n    uint public maxPendingMarketOrders = 5;\n    uint public maxGainP = 900;                          // %\n    uint public maxSlP = 80;                             // %\n    uint public defaultLeverageUnlocked = 50;            // x\n    uint public nftSuccessTimelock = 50;                 // 50 blocks\n    uint[5] public spreadReductionsP = [15,20,25,30,35]; // %\n\n    // Gov & dev addresses (updatable)\n    address public gov = 0xd7D1dCba2c678ee7e049BD55176354E7C5bBdcCA;\n    address public dev = 0xd39A38bD2D2d552f3908ff698a5530aa397fb92d;\n\n    // Gov & dev fees\n    uint public devFeesToken;   // 1e18\n    uint public devFeesDai;     // 1e18\n    uint public govFeesToken;   // 1e18\n    uint public govFeesDai;     // 1e18\n\n    // Stats\n    uint public tokensBurned;   // 1e18\n    uint public tokensMinted;   // 1e18\n    uint public nftRewards;     // 1e18\n\n    // Enums\n    enum LimitOrder { TP, SL, LIQ, OPEN }\n\n    // Structs\n    struct Trader{\n        uint leverageUnlocked;\n        address referral;\n        uint referralRewardsTotal;  // 1e18\n    }\n    struct Trade{\n        address trader;\n        uint pairIndex;\n        uint index;\n        uint initialPosToken;       // 1e18\n        uint positionSizeDai;       // 1e18\n        uint openPrice;             // PRECISION\n        bool buy;\n        uint leverage;\n        uint tp;                    // PRECISION\n        uint sl;                    // PRECISION\n    }\n    struct TradeInfo{\n        uint tokenId;\n        uint tokenPriceDai;         // PRECISION\n        uint openInterestDai;       // 1e18\n        uint tpLastUpdated;\n        uint slLastUpdated;\n        bool beingMarketClosed;\n    }\n    struct OpenLimitOrder{\n        address trader;\n        uint pairIndex;\n        uint index;\n        uint positionSize;          // 1e18 (DAI or GFARM2)\n        uint spreadReductionP;\n        bool buy;\n        uint leverage;\n        uint tp;                    // PRECISION (%)\n        uint sl;                    // PRECISION (%)\n        uint minPrice;              // PRECISION\n        uint maxPrice;              // PRECISION\n        uint block;\n        uint tokenId;               // index in supportedTokens\n    }\n    struct PendingMarketOrder{\n        Trade trade;\n        uint block;\n        uint wantedPrice;           // PRECISION\n        uint slippageP;             // PRECISION (%)\n        uint spreadReductionP;\n        uint tokenId;               // index in supportedTokens\n    }\n    struct PendingNftOrder{\n        address nftHolder;\n        uint nftId;\n        address trader;\n        uint pairIndex;\n        uint index;\n        LimitOrder orderType;\n    }\n\n    // Supported tokens to open trades with\n    address[] public supportedTokens;\n\n    // User info mapping\n    mapping(address => Trader) public traders;\n\n    // Trades mappings\n    mapping(address => mapping(uint => mapping(uint => Trade))) public openTrades;\n    mapping(address => mapping(uint => mapping(uint => TradeInfo))) public openTradesInfo;\n    mapping(address => mapping(uint => uint)) public openTradesCount;\n\n    // Limit orders mappings\n    mapping(address => mapping(uint => mapping(uint => uint))) public openLimitOrderIds;\n    mapping(address => mapping(uint => uint)) public openLimitOrdersCount;\n    OpenLimitOrder[] public openLimitOrders;\n\n    // Pending orders mappings\n    mapping(uint => PendingMarketOrder) public reqID_pendingMarketOrder;\n    mapping(uint => PendingNftOrder) public reqID_pendingNftOrder;\n    mapping(address => uint[]) public pendingOrderIds;\n    mapping(address => mapping(uint => uint)) public pendingMarketOpenCount;\n    mapping(address => mapping(uint => uint)) public pendingMarketCloseCount;\n\n    // List of open trades & limit orders\n    mapping(uint => address[]) public pairTraders;\n    mapping(address => mapping(uint => uint)) public pairTradersId;\n\n    // Current and max open interests for each pair\n    mapping(uint => uint[3]) public openInterestDai; // 1e18 [long,short,max]\n\n    // Restrictions & Timelocks\n    mapping(uint => uint) public tradesPerBlock;\n    mapping(uint => uint) public nftLastSuccess;\n\n    // List of allowed contracts => can update storage + mint/burn tokens\n    mapping(address => bool) public isTradingContract;\n\n    // Events\n    event SupportedTokenAdded(address a);\n    event TradingContractAdded(address a);\n    event TradingContractRemoved(address a);\n    event AddressUpdated(string name, address a);\n    event NftsUpdated(NftInterfaceV5[5] nfts);\n    event NumberUpdated(string name,uint value);\n    event NumberUpdatedPair(string name,uint pairIndex,uint value);\n    event SpreadReductionsUpdated(uint[5]);\n\n    constructor() { }\n\n    // Modifiers\n    modifier onlyGov(){ require(msg.sender == gov); _; }\n    modifier onlyTrading(){ require(isTradingContract[msg.sender] && token.hasRole(MINTER_ROLE, msg.sender)); _; }\n\n    // Manage addresses\n    function setGov(address _gov) external onlyGov{\n        require(_gov != address(0));\n        gov = _gov;\n        emit AddressUpdated(\"gov\", _gov);\n    }\n    function setDev(address _dev) external onlyGov{\n        require(_dev != address(0));\n        dev = _dev;\n        emit AddressUpdated(\"dev\", _dev);\n    }\n    function updateToken(TokenInterfaceV5 _newToken) external onlyGov{\n        require(trading.isPaused() && callbacks.isPaused(), \"NOT_PAUSED\");\n        require(address(_newToken) != address(0));\n        token = _newToken;\n        emit AddressUpdated(\"token\", address(_newToken));\n    }\n    function updateNfts(NftInterfaceV5[5] memory _nfts) external onlyGov{\n        require(address(_nfts[0]) != address(0));\n        nfts = _nfts;\n        emit NftsUpdated(_nfts);\n    }\n    // Trading + callbacks contracts\n    function addTradingContract(address _trading) external onlyGov{\n        require(token.hasRole(MINTER_ROLE, _trading), \"NOT_MINTER\");\n        require(_trading != address(0));\n        isTradingContract[_trading] = true;\n        emit TradingContractAdded(_trading);\n    }\n    function removeTradingContract(address _trading) external onlyGov{\n        require(_trading != address(0));\n        isTradingContract[_trading] = false;\n        emit TradingContractRemoved(_trading);\n    }\n    function addSupportedToken(address _token) external onlyGov{\n        require(_token != address(0));\n        supportedTokens.push(_token);\n        emit SupportedTokenAdded(_token);\n    }\n    function setPriceAggregator(address _aggregator) external onlyGov{\n        require(_aggregator != address(0));\n        priceAggregator = AggregatorInterfaceV5(_aggregator);\n        emit AddressUpdated(\"priceAggregator\", _aggregator);\n    }\n    function setPool(address _pool) external onlyGov{\n        require(_pool != address(0));\n        pool = PoolInterfaceV5(_pool);\n        emit AddressUpdated(\"pool\", _pool);\n    }\n    function setVault(address _vault) external onlyGov{\n        require(_vault != address(0));\n        vault = _vault;\n        emit AddressUpdated(\"vault\", _vault);\n    }\n    function setTrading(address _trading) external onlyGov{\n        require(_trading != address(0));\n        trading = PausableInterfaceV5(_trading);\n        emit AddressUpdated(\"trading\", _trading);\n    }\n    function setCallbacks(address _callbacks) external onlyGov{\n        require(_callbacks != address(0));\n        callbacks = PausableInterfaceV5(_callbacks);\n        emit AddressUpdated(\"callbacks\", _callbacks);\n    }\n    function setTokenDaiRouter(address _tokenDaiRouter) external onlyGov{\n        require(_tokenDaiRouter != address(0));\n        tokenDaiRouter = _tokenDaiRouter;\n        emit AddressUpdated(\"tokenDaiRouter\", _tokenDaiRouter);\n    }\n\n    // Manage trading variables\n    function setMaxTradesPerBlock(uint _maxTradesPerBlock) external onlyGov{\n        require(_maxTradesPerBlock > 0);\n        maxTradesPerBlock = _maxTradesPerBlock;\n        emit NumberUpdated(\"maxTradesPerBlock\", _maxTradesPerBlock);\n    }\n    function setMaxTradesPerPair(uint _maxTradesPerPair) external onlyGov{\n        require(_maxTradesPerPair > 0);\n        maxTradesPerPair = _maxTradesPerPair;\n        emit NumberUpdated(\"maxTradesPerPair\", _maxTradesPerPair);\n    }\n    function setMaxPendingMarketOrders(uint _maxPendingMarketOrders) external onlyGov{\n        require(_maxPendingMarketOrders > 0);\n        maxPendingMarketOrders = _maxPendingMarketOrders;\n        emit NumberUpdated(\"maxPendingMarketOrders\", _maxPendingMarketOrders);\n    }\n    function setMaxGainP(uint _max) external onlyGov{\n        require(_max >= 300);\n        maxGainP = _max;\n        emit NumberUpdated(\"maxGainP\", _max);\n    }\n    function setDefaultLeverageUnlocked(uint _lev) external onlyGov{\n        require(_lev > 0);\n        defaultLeverageUnlocked = _lev;\n        emit NumberUpdated(\"defaultLeverageUnlocked\", _lev);\n    }\n    function setMaxSlP(uint _max) external onlyGov{\n        require(_max >= 50);\n        maxSlP = _max;\n        emit NumberUpdated(\"maxSlP\", _max);\n    }\n    function setNftSuccessTimelock(uint _blocks) external onlyGov{\n        nftSuccessTimelock = _blocks;\n        emit NumberUpdated(\"nftSuccessTimelock\", _blocks);\n    }\n    function setSpreadReductionsP(uint[5] calldata _r) external onlyGov{\n        require(_r[0] > 0 && _r[1] > _r[0] && _r[2] > _r[1] && _r[3] > _r[2] && _r[4] > _r[3]);\n        spreadReductionsP = _r;\n        emit SpreadReductionsUpdated(_r);\n    }\n    function setMaxOpenInterestDai(uint _pairIndex, uint _newMaxOpenInterest) external onlyGov{\n        // Can set max open interest to 0 to pause trading on this pair only\n        openInterestDai[_pairIndex][2] = _newMaxOpenInterest;\n        emit NumberUpdatedPair(\"maxOpenInterestDai\", _pairIndex, _newMaxOpenInterest);\n    }\n\n    // Manage stored trades\n    function storeTrade(Trade memory _trade, TradeInfo memory _tradeInfo) external onlyTrading{\n        _trade.index = firstEmptyTradeIndex(_trade.trader, _trade.pairIndex);\n        openTrades[_trade.trader][_trade.pairIndex][_trade.index] = _trade;\n\n        openTradesCount[_trade.trader][_trade.pairIndex]++;\n        tradesPerBlock[block.number]++;\n\n        if(openTradesCount[_trade.trader][_trade.pairIndex] == 1){\n            pairTradersId[_trade.trader][_trade.pairIndex] = pairTraders[_trade.pairIndex].length;\n            pairTraders[_trade.pairIndex].push(_trade.trader); \n        }\n\n        _tradeInfo.beingMarketClosed = false;\n        openTradesInfo[_trade.trader][_trade.pairIndex][_trade.index] = _tradeInfo;\n\n        updateOpenInterestDai(_trade.pairIndex, _tradeInfo.openInterestDai, true, _trade.buy);\n    }\n    function unregisterTrade(address trader, uint pairIndex, uint index) external onlyTrading{\n        Trade storage t = openTrades[trader][pairIndex][index];\n        TradeInfo storage i = openTradesInfo[trader][pairIndex][index];\n        if(t.leverage == 0){ return; }\n\n        updateOpenInterestDai(pairIndex, i.openInterestDai, false, t.buy);\n\n        if(openTradesCount[trader][pairIndex] == 1){\n            uint _pairTradersId = pairTradersId[trader][pairIndex];\n            address[] storage p = pairTraders[pairIndex];\n\n            p[_pairTradersId] = p[p.length-1];\n            pairTradersId[p[_pairTradersId]][pairIndex] = _pairTradersId;\n            \n            delete pairTradersId[trader][pairIndex];\n            p.pop();\n        }\n\n        delete openTrades[trader][pairIndex][index];\n        delete openTradesInfo[trader][pairIndex][index];\n\n        openTradesCount[trader][pairIndex]--;\n        tradesPerBlock[block.number]++;\n    }\n\n    // Manage pending market orders\n    function storePendingMarketOrder(PendingMarketOrder memory _order, uint _id, bool _open) external onlyTrading{\n        pendingOrderIds[_order.trade.trader].push(_id);\n\n        reqID_pendingMarketOrder[_id] = _order;\n        reqID_pendingMarketOrder[_id].block = block.number;\n        \n        if(_open){\n            pendingMarketOpenCount[_order.trade.trader][_order.trade.pairIndex]++;\n        }else{\n            pendingMarketCloseCount[_order.trade.trader][_order.trade.pairIndex]++;\n            openTradesInfo[_order.trade.trader][_order.trade.pairIndex][_order.trade.index].beingMarketClosed = true;\n        }\n    }\n    function unregisterPendingMarketOrder(uint _id, bool _open) external onlyTrading{\n        PendingMarketOrder memory _order = reqID_pendingMarketOrder[_id];\n        uint[] storage orderIds = pendingOrderIds[_order.trade.trader];\n\n        for(uint i = 0; i < orderIds.length; i++){\n            if(orderIds[i] == _id){\n                if(_open){ \n                    pendingMarketOpenCount[_order.trade.trader][_order.trade.pairIndex]--;\n                }else{\n                    pendingMarketCloseCount[_order.trade.trader][_order.trade.pairIndex]--;\n                    openTradesInfo[_order.trade.trader][_order.trade.pairIndex][_order.trade.index].beingMarketClosed = false;\n                }\n\n                orderIds[i] = orderIds[orderIds.length-1];\n                orderIds.pop();\n\n                delete reqID_pendingMarketOrder[_id];\n                return;\n            }\n        }\n    }\n\n    // Manage open interest\n    function updateOpenInterestDai(uint _pairIndex, uint _leveragedPosDai, bool _open, bool _long) private{\n        uint index = _long ? 0 : 1;\n        uint[3] storage o = openInterestDai[_pairIndex];\n        o[index] = _open ? o[index] + _leveragedPosDai : o[index] - _leveragedPosDai;\n    }\n\n    // Manage open limit orders\n    function storeOpenLimitOrder(OpenLimitOrder memory o) external onlyTrading{\n        o.index = firstEmptyOpenLimitIndex(o.trader, o.pairIndex);\n        o.block = block.number;\n        openLimitOrders.push(o);\n        openLimitOrderIds[o.trader][o.pairIndex][o.index] = openLimitOrders.length-1;\n        openLimitOrdersCount[o.trader][o.pairIndex]++;\n    }\n    function updateOpenLimitOrder(OpenLimitOrder calldata _o) external onlyTrading{\n        if(!hasOpenLimitOrder(_o.trader, _o.pairIndex, _o.index)){ return; }\n        OpenLimitOrder storage o = openLimitOrders[openLimitOrderIds[_o.trader][_o.pairIndex][_o.index]];\n        o.positionSize = _o.positionSize;\n        o.buy = _o.buy;\n        o.leverage = _o.leverage;\n        o.tp = _o.tp;\n        o.sl = _o.sl;\n        o.minPrice = _o.minPrice;\n        o.maxPrice = _o.maxPrice;\n        o.block = block.number;\n    }\n    function unregisterOpenLimitOrder(address _trader, uint _pairIndex, uint _index) external onlyTrading{\n        if(!hasOpenLimitOrder(_trader, _pairIndex, _index)){ return; }\n\n        // Copy last order to deleted order => update id of this limit order\n        uint id = openLimitOrderIds[_trader][_pairIndex][_index];\n        openLimitOrders[id] = openLimitOrders[openLimitOrders.length-1];\n        openLimitOrderIds[openLimitOrders[id].trader][openLimitOrders[id].pairIndex][openLimitOrders[id].index] = id;\n\n        // Remove\n        delete openLimitOrderIds[_trader][_pairIndex][_index];\n        openLimitOrders.pop();\n\n        openLimitOrdersCount[_trader][_pairIndex]--;\n    }\n\n    // Manage NFT orders\n    function storePendingNftOrder(PendingNftOrder memory _nftOrder, uint _orderId) external onlyTrading{\n        reqID_pendingNftOrder[_orderId] = _nftOrder;\n    }\n    function unregisterPendingNftOrder(uint _order) external onlyTrading{\n        delete reqID_pendingNftOrder[_order];\n    }\n\n    // Manage open trade\n    function updateSl(address _trader, uint _pairIndex, uint _index, uint _newSl) external onlyTrading{\n        Trade storage t = openTrades[_trader][_pairIndex][_index];\n        TradeInfo storage i = openTradesInfo[_trader][_pairIndex][_index];\n        if(t.leverage == 0){ return; }\n        t.sl = _newSl;\n        i.slLastUpdated = block.number;\n    }\n    function updateTp(address _trader, uint _pairIndex, uint _index, uint _newTp) external onlyTrading{\n        Trade storage t = openTrades[_trader][_pairIndex][_index];\n        TradeInfo storage i = openTradesInfo[_trader][_pairIndex][_index];\n        if(t.leverage == 0){ return; }\n        t.tp = _newTp;\n        i.tpLastUpdated = block.number;\n    }\n    function updateTrade(Trade memory _t) external onlyTrading{ // useful when partial adding/closing\n        Trade storage t = openTrades[_t.trader][_t.pairIndex][_t.index];\n        if(t.leverage == 0){ return; }\n        t.initialPosToken = _t.initialPosToken;\n        t.positionSizeDai = _t.positionSizeDai;\n        t.openPrice = _t.openPrice;\n        t.leverage = _t.leverage;\n    }\n\n    // Manage referrals\n    function storeReferral(address _trader, address _referral) external onlyTrading{\n        Trader storage trader = traders[_trader];\n        trader.referral = _referral != address(0) && trader.referral == address(0) && _referral != _trader \n                        ? _referral : trader.referral;\n    }\n    function increaseReferralRewards(address _referral, uint _amount) external onlyTrading{ \n        traders[_referral].referralRewardsTotal += _amount; \n    }\n\n    // Manage rewards\n    function distributeLpRewards(uint _amount) external onlyTrading{ pool.increaseAccTokensPerLp(_amount); }\n    function increaseNftRewards(uint _nftId, uint _amount) external onlyTrading{\n        nftLastSuccess[_nftId] = block.number; \n        nftRewards += _amount; \n    }\n\n    // Unlock next leverage\n    function setLeverageUnlocked(address _trader, uint _newLeverage) external onlyTrading{\n        traders[_trader].leverageUnlocked = _newLeverage;\n    }\n\n    // Manage dev & gov fees\n    function handleDevGovFees(uint _pairIndex, uint _leveragedPositionSize, bool _dai, bool _fullFee) external onlyTrading returns(uint fee){\n        fee = _leveragedPositionSize * priceAggregator.openFeeP(_pairIndex) / PRECISION / 100;\n        if(!_fullFee){ fee /= 2; }\n\n        if(_dai){\n            govFeesDai += fee;\n            devFeesDai += fee;\n        }else{\n            govFeesToken += fee;\n            devFeesToken += fee;\n        }\n\n        fee *= 2;\n    }\n    function claimFees() external onlyGov{\n        token.mint(dev, devFeesToken);\n        token.mint(gov, govFeesToken);\n\n        tokensMinted += devFeesToken + govFeesToken;\n\n        dai.transfer(gov, govFeesDai);\n        dai.transfer(dev, devFeesDai);\n\n        devFeesToken = 0;\n        govFeesToken = 0;\n        devFeesDai = 0;\n        govFeesDai = 0;\n    }\n\n    // Manage tokens\n    function handleTokens(address _a, uint _amount, bool _mint) external onlyTrading{ \n        if(_mint){ token.mint(_a, _amount); tokensMinted += _amount; } \n        else { token.burn(_a, _amount); tokensBurned += _amount; } \n    }\n    function transferDai(address _from, address _to, uint _amount) external onlyTrading{ \n        if(_from == address(this)){\n            dai.transfer(_to, _amount); \n        }else{\n            dai.transferFrom(_from, _to, _amount); \n        }\n    }\n    function transferLinkToAggregator(address _from, uint _pairIndex, uint _leveragedPosDai) external onlyTrading{ \n        linkErc677.transferFrom(_from, address(priceAggregator), priceAggregator.linkFee(_pairIndex, _leveragedPosDai)); \n    }\n\n    // View utils functions\n    function firstEmptyTradeIndex(address trader, uint pairIndex) public view returns(uint index){\n        for(uint i = 0; i < maxTradesPerPair; i++){\n            if(openTrades[trader][pairIndex][i].leverage == 0){ index = i; break; }\n        }\n    }\n    function firstEmptyOpenLimitIndex(address trader, uint pairIndex) public view returns(uint index){\n        for(uint i = 0; i < maxTradesPerPair; i++){\n            if(!hasOpenLimitOrder(trader, pairIndex, i)){ index = i; break; }\n        }\n    }\n    function hasOpenLimitOrder(address trader, uint pairIndex, uint index) public view returns(bool){\n        if(openLimitOrders.length == 0){ return false; }\n        OpenLimitOrder storage o = openLimitOrders[openLimitOrderIds[trader][pairIndex][index]];\n        return o.trader == trader && o.pairIndex == pairIndex && o.index == index;\n    }\n\n    // Additional getters\n    function getReferral(address _trader) external view returns(address){ \n        return traders[_trader].referral; \n    }\n    function getLeverageUnlocked(address _trader) external view returns(uint){ \n        return traders[_trader].leverageUnlocked; \n    }\n    function pairTradersArray(uint _pairIndex) external view returns(address[] memory){ \n        return pairTraders[_pairIndex]; \n    }\n    function getPendingOrderIds(address _trader) external view returns(uint[] memory){ \n        return pendingOrderIds[_trader]; \n    }\n    function pendingOrderIdsCount(address _trader) external view returns(uint){ \n        return pendingOrderIds[_trader].length; \n    }\n    function getOpenLimitOrder(\n        address _trader, \n        uint _pairIndex,\n        uint _index\n    ) external view returns(OpenLimitOrder memory){ \n        require(hasOpenLimitOrder(_trader, _pairIndex, _index), \"23\");\n        return openLimitOrders[openLimitOrderIds[_trader][_pairIndex][_index]]; \n    }\n    function getOpenLimitOrders() external view returns(OpenLimitOrder[] memory){ \n        return openLimitOrders; \n    }\n    function getSupportedTokens() external view returns(address[] memory){ \n        return supportedTokens; \n    }\n    function getSpreadReductionsArray() external view returns(uint[5] memory){\n        return spreadReductionsP;\n    }\n}"
    },
    "contracts/interfaces/AggregatorInterfaceV5.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\ninterface AggregatorInterfaceV5{\n    enum OrderType { MARKET_OPEN, MARKET_CLOSE, LIMIT_OPEN, LIMIT_CLOSE }\n    function getPrice(uint,OrderType,uint) external returns(uint);\n    function tokenPriceDai() external view returns(uint);\n    function pairMinOpenLimitSlippageP(uint) external view returns(uint);\n    function closeFeeP(uint) external view returns(uint);\n    function linkFee(uint,uint) external view returns(uint);\n    function openFeeP(uint) external view returns(uint);\n    function pairMinLeverage(uint) external view returns(uint);\n    function pairMaxLeverage(uint) external view returns(uint);\n    function pairsCount() external view returns(uint);\n    function tokenDaiReservesLp() external view returns(uint, uint);\n    function referralP(uint) external view returns(uint);\n    function nftLimitOrderFeeP(uint) external view returns(uint);\n}"
    },
    "contracts/interfaces/NftInterfaceV5.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\ninterface NftInterfaceV5{\n    function balanceOf(address) external view returns (uint);\n    function ownerOf(uint) external view returns (address);\n    function transferFrom(address, address, uint) external;\n    function tokenOfOwnerByIndex(address, uint) external view returns(uint);\n}"
    },
    "contracts/interfaces/PausableInterfaceV5.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\ninterface PausableInterfaceV5{\n    function isPaused() external view returns (bool);\n}"
    },
    "contracts/interfaces/PoolInterfaceV5.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\ninterface PoolInterfaceV5{\n    function increaseAccTokensPerLp(uint) external;\n}"
    },
    "contracts/interfaces/TokenInterfaceV5.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\ninterface TokenInterfaceV5{\n    function burn(address, uint256) external;\n    function mint(address, uint256) external;\n    function transfer(address, uint256) external returns (bool);\n    function transferFrom(address, address, uint256) external returns(bool);\n    function balanceOf(address) external view returns(uint256);\n    function hasRole(bytes32, address) external view returns (bool);\n    function approve(address, uint256) external returns (bool);\n    function allowance(address, address) external view returns (uint256);\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}